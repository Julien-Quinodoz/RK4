ğŸ” Partie 1 : Inclusions et struct

#include <stdio.h>      // pour printf
#include <stdlib.h>     // pour calloc, free
#include <ctype.h>      // pour isdigit

ğŸ“¦ DÃ©finition de lâ€™arbre syntaxique

typedef struct node {
    enum {
        ADD,    // addition
        MULTI,  // multiplication
        VAL     // valeur (chiffre)
    } type;

    int val;           // utilisÃ© seulement si type == VAL
    struct node *l;    // sous-arbre gauche
    struct node *r;    // sous-arbre droit
} node;

ğŸ§  Ce struct est utilisÃ© pour reprÃ©senter un nÅ“ud dâ€™arbre d'expression mathÃ©matique :

Chaque opÃ©rateur + ou * crÃ©e un nÅ“ud interne avec deux branches (gauche et droite).

Chaque chiffre est une feuille (VAL) avec une valeur.

âš™ï¸ Fonctions utilitaires
ğŸ”¨ new_node


node *new_node(node n)
{
    node *ret = calloc(1, sizeof(n)); // alloue un nouveau noeud initialisÃ© Ã  0
    if (!ret)
        return (NULL);
    *ret = n; // copie les champs de `n`
    return (ret);
}
ğŸ§  CrÃ©e proprement un nouveau node Ã  partir dâ€™un modÃ¨le.

ğŸ§¹ destroy_tree


void destroy_tree(node *n)
{
    if (!n) return;
    if (n->type != VAL) // si ce nâ€™est pas une feuille, libÃ¨re les branches
    {
        destroy_tree(n->l);
        destroy_tree(n->r);
    }
    free(n); // libÃ¨re le nÅ“ud lui-mÃªme
}
ğŸ§  LibÃ¨re rÃ©cursivement tout lâ€™arbre en mÃ©moire.

â— unexpected


void unexpected(char c)
{
    if (c)
        printf("Unexpected token '%c'\n", c);
    else
        printf("Unexpected end of file\n");
}
ğŸ§  Affiche un message dâ€™erreur clair si un caractÃ¨re inattendu ou une fin de chaÃ®ne est atteinte.

âœ… accept et expect


int accept(char **s, char c)
{
    if (**s == c)
    {
        (*s)++;
        return 1;
    }
    return 0;
}
ğŸ§  accept teste si le prochain caractÃ¨re est c. Si oui, avance le pointeur.



int expect(char **s, char c)
{
    if (accept(s, c))
        return 1;
    unexpected(**s);
    return 0;
}
ğŸ§  expect est comme accept, mais affiche une erreur si le caractÃ¨re attendu nâ€™est pas lÃ .

ğŸ§  Ã‰valuation de lâ€™arbre


int eval_tree(node *tree)
{
    switch (tree->type)
    {
        case ADD:
            return eval_tree(tree->l) + eval_tree(tree->r);
        case MULTI:
            return eval_tree(tree->l) * eval_tree(tree->r);
        case VAL:
            return tree->val;
    }
}


ğŸ§  Ã‰value rÃ©cursivement lâ€™expression :

addition â†’ additionne les sous-arbres

multiplication â†’ multiplie les sous-arbres

valeur â†’ retourne la valeur



ğŸ§® Fonctions de parsing (analyse syntaxique)
parse_factor


node *parse_factor(char **s)
{
    if (isdigit(**s)) // chiffre
    {
        node n = { VAL, **s - '0', NULL, NULL };
        (*s)++;
        return new_node(n);
    }
    if (accept(s, '(')) // parenthÃ¨se ouvrante
    {
        node *n = parse_expr(s); // sous-expression
        if (!expect(s, ')'))     // parenthÃ¨se fermante attendue
        {
            destroy_tree(n);
            return NULL;
        }
        return n;
    }
    unexpected(**s); // autre caractÃ¨re invalide
    return NULL;
}
ğŸ§  GÃ¨re les chiffres simples ou parenthÃ¨ses, donc les Ã©lÃ©ments de base de lâ€™expression.

parse_term


node *parse_term(char **s)
{
    node *left = parse_factor(s); // commence par un facteur
    if (!left) return NULL;

    while (accept(s, '*')) // tant quâ€™on trouve des multiplications
    {
        node *right = parse_factor(s);
        if (!right)
        {
            destroy_tree(left);
            return NULL;
        }
        node n = { MULTI, 0, left, right }; // crÃ©e un nÅ“ud MULTI
        left = new_node(n); // devient le nouveau point dâ€™ancrage
        if (!left)
        {
            destroy_tree(right);
            return NULL;
        }
    }
    return left;
}
ğŸ§  GÃ¨re les multiplications a*b*c, prioritÃ© avant +.

parse_expr


node *parse_expr(char **s)
{
    node *left = parse_term(s);
    if (!left) return NULL;

    while (accept(s, '+')) // tant quâ€™on trouve des additions
    {
        node *right = parse_term(s);
        if (!right)
        {
            destroy_tree(left);
            return NULL;
        }
        node n = { ADD, 0, left, right }; // crÃ©e un nÅ“ud ADD
        left = new_node(n);
        if (!left)
        {
            destroy_tree(right);
            return NULL;
        }
    }
    return left;
}
ğŸ§  GÃ¨re les additions, prioritÃ© la plus faible.

ğŸ¬ main


int main(int argc, char **argv)
{
    if (argc != 2) return 1;

    char *s = argv[1];
    node *tree = parse_expr(&s);
    if (!tree) return 1;

    if (*s) // si reste de lâ€™expression non analysÃ©
    {
        unexpected(*s);
        destroy_tree(tree);
        return 1;
    }

    printf("%d\n", eval_tree(tree)); // affiche le rÃ©sultat
    destroy_tree(tree);              // nettoyage
}



ğŸ§  Fonction principale :

VÃ©rifie quâ€™un argument est donnÃ©

Parse lâ€™expression

Si parsing OK, Ã©value lâ€™arbre et affiche

Sinon, affiche une erreur

LibÃ¨re la mÃ©moire

ğŸ§ª Exemple complet
Input :
bash
./a.out "2+3*4"

Analyse :
3*4 â†’ d'abord MULTI

puis 2+12 â†’ ADD

RÃ©sultat : 14

âœ… En rÃ©sumÃ©
Fonction	RÃ´le
parse_expr	GÃ¨re les +
parse_term	GÃ¨re les *
parse_factor	GÃ¨re chiffres & parenthÃ¨ses
eval_tree	Ã‰value lâ€™arbre
main	Orchestration + sÃ©curitÃ©

